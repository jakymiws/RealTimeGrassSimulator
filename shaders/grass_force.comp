#version 430

layout (std430, binding=0) buffer grassBladePosition {
    vec4 pos[];
};

layout (std430, binding=1) buffer grassBladeV1 {
    vec4 cV1[];
};

layout (std430, binding=2) buffer grassBladeV2 {
    vec4 cV2[];
};

layout (std430, binding=3) buffer grassProps {
    vec4 props[];
};

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

uniform float frameNum;

void main()
{
    uint id = gl_GlobalInvocationID.x;

    float blade_stiffness = props[id].w;
    float blade_height = cV1[id].w;
    float blade_width = cV2[id].w;
    vec3 blade_up = props[id].xyz;
    
    float blade_direction_radians = pos[id].w;
    float sinDir = sin(blade_direction_radians);
    float cosDir = cos(blade_direction_radians);
    vec3 blade_direction = normalize(cross(blade_up, normalize(vec3(sinDir, sinDir+cosDir, cosDir))));
    vec3 front_direction = normalize(cross(blade_up, blade_direction));

    vec3 p = pos[id].xyz;
    vec3 v1 = cV1[id].xyz;
    vec3 v2 = cV2[id].xyz;

    //force computation
    float dt = 0.1;

    vec3 initialPoseV2 = p + blade_up*blade_height;

    vec3 recovery_force = (initialPoseV2 - v2)*blade_stiffness;

    float gravity_acceleration =0.981;
    vec3 gravity_direction = vec3(0, -1.0 ,0);
    vec3 environmental_gravity = gravity_direction * gravity_acceleration;//regular physical gravity.
    vec3 local_front_gravity = 0.25 * length(environmental_gravity) * front_direction;//approximation of grass bending due to gravity.
    vec3 gravity_force = environmental_gravity + local_front_gravity;

    vec3 wi = vec3(1.0, 0.2, 1.0) * sin(frameNum) * 1.0;
    float windFd = 1 - abs( dot(normalize(wi), normalize(v2-p)));
    float windFr = dot(v2-p, blade_up)/blade_height;
    float windTheta = windFd*windFr;
    vec3 wind_force = wi*windTheta;

    vec3 computed_blade_translation = (recovery_force + gravity_force + wind_force) * dt;

    //apply integrated force
    v2 += computed_blade_translation;

    //validate state of control points
    v2 = v2 - blade_up * min(blade_up*(v2-p), 0.0);

    float lengthProj = length(v2 - p - blade_up*((v2-p)*blade_up));

    if (abs(lengthProj) > 0.00001)
    {
        float lpH = lengthProj/blade_height;
        v1 = p + blade_height * blade_up * max(1 - lpH, 0.05*max(lpH, 1.0));
    }

    float L = (2*length(p-v2) + length(p-v1) + length(v1-v2)) / 3.0;
    float r = blade_height/L;

    vec3 v1_corrected = p + r*(v1-p);
    vec3 v2_corrected = v1_corrected + r*(v2-v1);

    cV1[id] = vec4(v1_corrected, blade_height);
    cV2[id] = vec4(v2_corrected, blade_width);

}