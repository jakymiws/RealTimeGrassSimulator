#version 430

layout (std430, binding=0) buffer grassBladePosition {
    vec4 pos[];
};

layout (std430, binding=1) buffer grassBladeV1 {
    vec4 cV1[];
};

layout (std430, binding=2) buffer grassBladeV2 {
    vec4 cV2[];
};

layout (std430, binding=3) buffer grassProps {
    vec4 props[];
};


layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint id = gl_GlobalInvocationID.x;
    
    float blade_height = cV1[id].w;
    float blade_stiffness = props[id].w;
    
    vec3 up = props[id].xyz;

    //future uniforms
    float dt = 0.1;
    float gravity_acceleration = 9.81;

    float direction =  pos[id].w;
    float sinDir = sin(direction);
    float cosDir = cos(direction);
    vec3 blade_direction = normalize(cross(up, normalize(vec3(sinDir, sinDir+cosDir, cosDir))));
    vec3 front_direction = normalize(cross(up, blade_direction));

    vec3 p = pos[id].xyz;
    vec3 v1 = cV1[id].xyz;
    vec3 v2 = cV2[id].xyz;
    vec3 iv2 = p + up*blade_height;

    //Force Computation and Application
    vec3 recovery = (iv2 - v2) *(1.0 -  blade_stiffness * 0.25);
    
    vec3 env_gravity = normalize(vec3(0, -1.0, 0)) * gravity_acceleration;
    vec3 local_gravity = (0.25) * length(env_gravity) * front_direction;
    vec3 gravity = env_gravity + local_gravity;
    vec3 wind = vec3(0.0);

    //vec3 blade_translation = (recovery + gravity + wind)*dt;
    vec3 blade_translation = (recovery + gravity + wind)*dt;

    v2 += blade_translation;

    //State Validation
    v2 = v2 - up * min(dot(up, v2-p), 0.0);

    float lproj = length(v2 - p - up*(dot(v2-p, up))); 

    if (abs(lproj) < 0.000001)
    {
        float lproj_h = lproj/blade_height;
        v1 = p + blade_height*up*max(1.0 - lproj_h, 0.05*max(lproj_h, 1));
    }

    float L1 = length(v2-v1) + length(v1-p);

    //Bezier curve approx from Graveson 1993. Assuming degree of curve is 2 - is it 3 perhaps?
    float curve_length = (2*length(v2-p) + L1)/3.0;
    float ratio = blade_height/curve_length;

    vec3 v1_validated = p + ratio*(v1-p);
    vec3 v2_validated = v1_validated + ratio*(v2-v1);

    pos[id] = vec4(p, 1.0);
    cV1[id] = vec4(v1_validated, 1.0);
    cV2[id] = vec4(v2_validated, 1.0);
}